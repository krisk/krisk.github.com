<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="http://kiro.me/textualizer/javascript/prettify.js"></script>
    <script src="http://code.jquery.com/jquery-1.6.2.min.js"></script>
    <link href="http://kiro.me/textualizer/style/prettify.css" type="text/css" rel="stylesheet" />
    <link href="http://kiro.me/textualizer/style/main.css" rel="stylesheet" type="text/css"></style>
    <script type="text/javascript" src="http://google-code-prettify.googlecode.com/svn/trunk/src/lang-css.js"></script>
    <script type="text/javascript" src="http://google-code-prettify.googlecode.com/svn/trunk/src/lang-html.js"></script>
    <style type="text/css">
        h2
        {
            clear: both;
        }
        
        div.figure
        {
            font-size: 80%;
            margin: 5px;
        }
        div.figure > div
        {
            margin-bottom: 5px;
        }
    </style>
  </head>
  <body>
      <div id="container">
        <p>
          If you're reached this page, then it probably means you're <strong>Andrew Lottmann</strong>.  If that's the case, then great.
        Although we're in the process of changing the name of this library, right now, it is still unceremoniously called "The Component Infrastructure".
        </p>
        <p>
    <h2>Background</h2>
    <p>
        <div class="figure" style="float: right; width: 228px; margin-left: 15px;">
            <div>
                <img src="images/BlockDiagram.png" /></div>
            <div>
                <strong>Figure 1</strong> - Block Diagram of a Component</div>
        </div>
        As web applications grow more and more complicated, increasing amounts of modularity
        have to be introduced into the application design. One place where this modularization
        has historically been difficult to achieve has been in the User Interface layer.
        One industry tested method of achieving this modularization is through the use of
        UI Controls. UI Controls are code blocks that encapsulate the look and behaviour
        of a small chunk of the entire User Interface. Well known examples of UI controls
        include buttons, checkboxes, and radio buttons. The Component Infrastructure is
        a set of JavaScript code blocks that provide a solid foundation to build modular
        UI Controls for use in Web 2.0+ applications. The overarching design of the infrastructure
        is the idea that all UI Controls are separable into four unique parts:
        <ul>
            <li><strong>Structure:</strong> HTML, SVG, MathML, etc...</li>
            <li><strong>Look:</strong> CSS</li>
            <li><strong>Feel:</strong> Event Driven JavaScript</li>
            <li><strong>Behaviour:</strong> Logic implemented as JavaScript</li>
        </ul>
        Accordingly, the infrastructure completely separates these four parts into distinct
        code modules which allows for very low coupling and high cohesion (two highly desirable
        software engineering traits). The infrastructure seamlessly assembles these constituent
        parts into a single entity, allowing Control authors not to get mired in the overly
        technical aspects of page design. In addition, because each component is a completely
        independent entity, they are reusable and customizable.
    </p>
    <h2>Composability</h2>
    <p>
        <div class="figure" style="float: left; width: 228px; margin-right: 15px;">
            <div>
                <img src="images/Composition.png" /></div>
            <div>
                <strong>Figure 2</strong> - Block Diagram of a Component</div>
        </div>
        Composability in UI architecture refers to property of UI Controls where individual
        UI Controls are able to <em>assemble</em> together to create a more complex UI representation
        which is still reusable. For example, on a hypothetical dashboard, all widgets are
        required to have a title bar, and Maximize/Minimize buttons as part of their frame
        decoration. If you already have Controls representing Buttton, Frame, and Label,
        you can assemble them into a widget decorator with little hassle. Composability is
        a core part of the Component Infrastructure and is implemented through the use of
        Declarative Mark-up and explicit Parent/Child relationships between individual Components.
        In addition, the Composition Hierarchy of the infrastructure is not tied to the
        DOM hierarchy allowing for expressive composition relationships. Figure 2 shows
        a potential Composition Hierarchy for a Component.
    </p>
    <h2>Flexibility</h2>
    <p>
        At run time, there are two primary paradigms of creating rich UI controls. The first
        is to use JavaScript to completely construct the necessary HTML code, while the
        second is to use JavaScript to build a richer representation of existing HTML nodes
        in a document. In practice, existing libraries are restricted to the usage of one
        method or the other. The Component Infrastructure, on the other hand, promotes a
        pragmatic approach to the choice of methods. For some components it makes sense
        to use the second method since it simplifies the generation of DOM, whereas for
        others it may be preferable to use the first for reasons of performance or ease
        of implementation. Either way, the Component Infrastructure does not enforce either
        and leaves the choice to the Control author. This flexibility allows authors to
        create non-HTML based Controls, such as SVG, MathML, XML, and even Flash. This design
        also allows for the usage of third party controls which do not use have awareness
        of the Component Infrastructure in any way. For example, a jQuery UI control could
        be initialized within a Component, or perhaps let the jQuery UI control wrap around
        an existing Component.</p>
<h2>Example</h2>
        <p>
          In this example I'll be creating a simple contact component, which contains a name, first name, address, and phone number. 
        </p>
        <h3>Structure</h3>
        <p>
          Templates use the <a href="http://mustache.github.com/">Mustache</a> templating engine.
        </p>
          <pre class="prettyprint lang-html">
&lt;div&gt;
    &lt;span name=&quot;firstName&quot;&gt;{{firstName}}&lt;/span&gt;
    &lt;span&gt;{{lastName}}&lt;/span&gt;
    &lt;span&gt;{{address}}&lt;/span&gt;
    &lt;span name=&quot;phone&quot;&gt;{{phone}}&lt;/span&gt;
&lt;/div&gt;
          </pre>
        <h3>Look</h3>
        <pre class="prettyprint lang-css">
.contact {  
  border: 1px solid 'Red';
}
.contact > span {
  font-weight: bold;
}
        </pre>
        <h3>Logic</h3>
        <p>
          Currently, the entire architecture is heavily reliant on jQuery (perhaps that will change, but we're still discussing...)
        </p>
          <pre class="prettyprint lang-js">
(function ($, undefined) {

    // This entire code block inherits from the root Component 
    var Contact = function () {
        this._nickName = null;

        this.onPhoneNumberClick$proxy = $.proxy(this.onPhoneNumberClick, this);
    }

    Contact.defaultOptions = {};

    Contact.prototype = $.extend(new base.constructor(), {

        // We'll override the bindEvents functions of its base class 
        // (which in this case happens to be Component)
        // (bindEvents is called after all child components have been instantiated)
        bindEvents: function() {

            // Note: the Component model automatically creates a jQuery object from 
            // DOM nodes within the template that have a name attributes.
            // That is, in the template, we have &lt;span name=&quot;phone&quot;&gt;...&lt;/span&gt;.  
            // Thus for this specific instance, "this._phone" represents that DOM node.
            this._phone.bind('click', this.onPhoneNumberClick$proxy);

            // Now call the base bindEvents function.
            base.bindEvents.apply(this, arguments);
        }

        // Styling
        , cssClassPrefix: function() {
            return 'contact';
        }

        // Getter/Setter method
        , nickName: function (/*text*/) {
            if (arguments.length === 0) {
                return this._nickName;
            } else {
                this._nickName = arguments[0];
            }
        }

        // Basic callback for when the phone number is clicked
        , onPhoneNumberClick: function() {
            // ...
        }
    });

    window.getComponentType = function () {
        return Contact;
    }
})(jQuery);
</pre>
<h3>Example use</h3>
<pre class="prettyprint">
// Create a new contact
myContact = new Component.Contact();

// Give the data
myContact.dataSource({
    firstName: 'Kirollos', 
    lastName: 'Risk', 
    address: 'Somewhere in Toronto', 
    phone: '911'
});

// Render it into the body
myContact.render($(document.body));

// Let's set the nickname
myContact.nickName('Kiro')
</pre>
  </body>
  <script type="text/javascript">
    $(function() {
          prettyPrint();
    })
  </script>
</html>